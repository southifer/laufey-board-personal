config = {
    ["showAnimation"] = false,
    ["moveInterval"] = 100,
    ["moveRange"] = 8,

    ["worldList"] = "C:\\Users\\Administrator\\Desktop\\FARM.txt",
    ["itmId"] = 102,
    ["itmSeed"] = 103,

    ["freshBot"] = false,
    ["freshBotLevel"] = 1,

    ["autoFill"] = false,
    ["detectFloat"] = true,
    ["restAfterFarm"] = false,

    ["itemHand"] = 98,
    ["takePick"] = false,
    ["worldPickaxeList"] = {
        "K418"
    },
    ["doorPickaxe"] = "111",

    ["storagePackList"] = {
        "BZTWXVLGAA|XOZHXTZK",
    },
    ["storageSeedList"] = {
        "0P9B0U8P1F8O3Y|8ASGBDB2"
    },
    ["storageVileList"] = {
        -- "0N3J3B8O3K2Z6V|8ASGBDB2"
        "MNUMSJXXHH|FNJFSCLT"
    },
    ["tileNumber"] = 4,
    ["customTile"] = true,
    ["customX"] = 5,
    ["customY"] = 1,
    ["pnbInTutorial"] = false,
    ["whiteListOwner"] = "X",
    ["differentWorldPNB"] = true,
    ["worldListPNB"] = "C:\\Users\\Administrator\\Desktop\\BREAK.txt",
    ["malady"] = {
        ["enable"] = true,
        ["infect"] = true,
        ["id"] = 8542,
        ["webhook"] = {
            ["url"] = "https://discord.com/api/webhooks/1250628915416793190/9u1IGFBl06Hnkbs8bMGmJAFCGmnW0PqZO3BESylNNQk0_lfh4XVFmidcc_zIssR7c-jl",
            ["id"] = 1284078522758856789
        },
        [1] = { -- Torn Punch
            ["world"] = {"MEMANCING|"},
            ["x"] = 60,
            ["y"] = 20,
        },
        [2] = { -- Gems Cut
            ["world"] = {"MEMANCING|"},
            ["x"] = 59,
            ["y"] = 20,
        }
    },
    ["autoRest"] = {
        ["enable"] = false,
        ["disconnectRest"] = true,
        ["duration"] = 80,
        ["interval"] = math.random(1800, 2100)
    },
    ["autoWear"] = {
        ["enable"] = false,
        ["buy"] = {
            ["enable"] = true,
            ["price"] = 5000,
        },
        ["id"] = 10158
    },
    ["interval"] = {
        ["harvest"] = 110,
        ["plant"] = 110,
        ["punch"] = 160,
        ["place"] = 110,
        ["warp"] = 12000,
        ["connect"] = 30,
        ["execute"] = 2500
    },
    ["purchase"] = {
        ["name"] = "world_lock",
        ["list"] = {242, 1796},
        ["price"] = 2000,
        ["minimumGem"] = 10000
    },
    ["event"] = {
        ["enable"] = false,
        ["list"] = {
            {["id"] = 1058, ["count"] = 25},
            {["id"] = 1094, ["count"] = 25},
            {["id"] = 1096, ["count"] = 25},
            {["id"] = 1098, ["count"] = 25},
            {["id"] = 1828, ["count"] = 5}, -- Balance mooncake
            {["id"] = 3870, ["count"] = 25},
            {["id"] = 7058, ["count"] = 25},
            {["id"] = 10134, ["count"] = 25},
            {["id"] = 10136, ["count"] = 25},
            {["id"] = 10138, ["count"] = 25},
            {["id"] = 10140, ["count"] = 25},
            {["id"] = 10142, ["count"] = 25},
            {["id"] = 10146, ["count"] = 25},
            {["id"] = 10150, ["count"] = 25},
            {["id"] = 10164, ["count"] = 25},
            {["id"] = 10228, ["count"] = 25},
            {["id"] = 11286, ["count"] = 25},
        },
        ["world"] = "0N3J3B8O3K2Z6V|8ASGBDB2",
        ["webhook"] = {
            ["url"] = "https://discord.com/api/webhooks/1250628915416793190/9u1IGFBl06Hnkbs8bMGmJAFCGmnW0PqZO3BESylNNQk0_lfh4XVFmidcc_zIssR7c-jl",
            ["id"] = 1284078454811136003
        }
    },
    ["webhook"] = {
        ["enable"] = false,
        ["info"] = "https://discord.com/api/webhooks/1266302365670309992/LEp1iuitQSveg86IcpylIKfUSEFboPcTQqo-WDxuK05-PQEFf2iHHBiIp1AGVRJlIgnX",
        ["pack"] = "https://discord.com/api/webhooks/1266302474629677106/eJTfR_TdpVSk09k2PTEoVgMyVYE4XsL3DL4EYbTIHHE2yycjba02e6tDcuJEJWAE4gHw",
        ["seed"] = "https://discord.com/api/webhooks/1266302534889504778/_j3q3j5n0lUBE8OUye8gfHabRCsKPBSN39OYOk_n2b0pbz67cVqTUfQB2w77vczmsLRM",
        ["world"] = "https://discord.com/api/webhooks/1266302586475249746/pv2PJJR5Vsh9616TMUHk98iV-kFDE-FBItmE2DWh05Xv-zMovHvYPzJdJ56j6btdV_KN",
        ["bot"] = {
            ["url"] = "https://discord.com/api/webhooks/1250628915416793190/9u1IGFBl06Hnkbs8bMGmJAFCGmnW0PqZO3BESylNNQk0_lfh4XVFmidcc_zIssR7c-jl",
            ["id"] = 1285173339953827997
        }
    },
    ["API"] = "",

    ["changeColorSkin"] = true,
    ["buyCloth"] = true,
    ["editNoteProfile"] = true,
    ["randomChat"] = true,
    ["randomWorld"] = false,

    ["claimGoals"] = {
        ["enable"] = true,
        ["world"] = "POOC",
        ["doorId"] = ""
    },

    ["chatList"] = {
        'I love NOIR love NOIR love NOIR love NOIR love NOIR love NOIR love NOIR love NOIR love NOIR love NOIR love NOIR love NOIR'
    },

    ["emoteList"] = {
        "/troll","/lol","/smile","/cry","/mad","/wave","/dance","/dab",
        "/love","/kiss","/sleep","/yes","/no","/wink","/cheer","/sad","/fp",
    },

    ["whiteList"] = {98, 18, 32, 6336, 9640, 242, 1796, 4584, 4585, 1486, 3066, 818, 202, 204, 206, 222, 223, 102, 103},
}

bot = getBot()
bot.legit_mode = config["showAnimation"]
bot.move_interval = config["moveInterval"]
bot.move_range = config["moveRange"]

for i, botz in pairs(getBots()) do
    if botz.name:upper() == bot.name:upper() then
        indexBot = i
    end
    indexLast = i
end

bot.collect_range = 3
bot.collect_interval = 150
bot.reconnect_interval = config["interval"]["connect"]

bot.disconnect_on_rest = config["autoRest"]["disconnectRest"]
bot.auto_rest_mode = config["autoRest"]["enable"]
bot.rest_time = config["autoRest"]["duration"]
bot.rest_interval = config["autoRest"]["interval"]

world = ""
doorFarm = ""
worldPNB = ""
worldBreak = ""
doorBreak = ""
cray = ""
list = {}
mode3Tile = {-2,-1,0,1,2}
tileBreak = {}
worldListBot = {}
tilePath = {}
fired = false
nuked = false
storageIndex = 1
warpStatus = ""
waktuWorld = {}
treeWorld = {}
uptime = os.time()

dividerSPick = math.ceil(indexLast / #config["worldPickaxeList"])
worldPickaxe = config["worldPickaxeList"][math.ceil(indexBot / dividerSPick)]

ItemSprites = {
    {name = "Harmony Mooncake", id = 1058, emote = "<:harmony_mooncake:1017892146520539197>"},
    {name = "Peace Mooncake", id = 1094, emote = "<:peace_mooncake:1017892143110561912>"},
    {name = "Longevity Mooncake", id = 1096, emote = "<:longevity_mooncake:1017892150354137221>"}, 
    {name = "Prosperity Mooncake", id = 1098, emote = "<:prosperity_mooncake:1017892140191322133>"},
    {name = "Balance Mooncake", id = 1828, emote = "<:balance_mooncake:1017344823532994561>"},
    {name = "Mooncake Bundle", id = 10228, emote = "<:mooncakebundle:1284084141066817546>"},
}

for i = math.floor(config["tileNumber"] / 2), 1, -1 do
    i = i * -1
    table.insert(tileBreak,i)
end

for i = 0, math.ceil(config["tileNumber"] / 2) - 1 do
    table.insert(tileBreak,i)
end

for _,item in pairs(config["purchase"]["list"]) do
    table.insert(config["whiteList"], item)
end

for ye = 1, 53 do
    local start, stop, step
    if ye % 4 == 1 then
        start, stop, step = 0, 99, 1
    else
        start, stop, step = 99, 0, -1
    end
    for ex = start, stop, step do
        table.insert(tilePath, {x = ex, y = ye})
    end
end

function getItemName(id)
    for _, item in ipairs(ItemSprites) do
        if item.id == id then
            return item
        end
    end
    return {emote = "<:ItemSprites2:1284081706692776006>"}
end

function displayWaktu()
    local str = ""
    for i, w in pairs(worldListBot) do
        str = str .. "\n" .. i .. ". " ..w:upper() .. " | " .. (waktuWorld[w] or "?") .. " | " .. (treeWorld[w] or "?")
    end
    return str
end

function punch(x,y)
    return bot:hit(bot.x + x,bot.y + y)
end

function findItem(id)
    return bot:getInventory():findItem(id) or 0
end

function place(id,x,y)
    return bot:place(bot.x + x,bot.y + y,id)
end

function tilePunch(x,y)
    for _,num in pairs(tileBreak) do
        if getTile(x + num,y).fg == config["itmId"] then
            return true
        end
    end
    return false
end

function tilePlace(x,y)
    for _,num in pairs(tileBreak) do
        if getTile(x + num,y).fg == 0 then
            return true
        end
    end
    return false
end

function growscan(id)
    return (bot:getWorld().growscan:getTiles()[id] or 0)
end

function append_to_file(filename, text)
    local file = io.open(filename, "a") -- Buka file dalam mode append
    if file then
        file:write(text .. "\n") -- Menambahkan teks ke file (dengan tambahan newline)
        file:close() -- Tutup file
        print(text .. ' berhasil di tambahkan (APPEND)')
    else
        print(text .. ' gagal di tambahkan (APPEND)')
    end
end

function checkActiveJammer()
    for _, tile in pairs(getTiles()) do
        if tile.fg == 226 and tile:hasFlag(64) then
            return true
        end
    end
    return false
end

-- Fungsi untuk membaca isi file 
function read_file(filename)
    local file = io.open(filename, "r") -- Buka file dalam mode baca
    if file then
        local content = file:read("*all") -- Baca seluruh isi file
        file:close() -- Tutup file
        return content
    else
        return ""
    end
end

-- Fungsi untuk menulis isi file
function write_file(filename, content)
    local file = io.open(filename, "w") -- Buka file dalam mode tulis
    if file then
        file:write(content) -- Tulis isi ke file
        file:close() -- Tutup file
        return true
    else
        return false
    end
end

function deleteNuke(world)
    -- Nama file yang akan diubah
    local filename = config["worldListPNB"]
    -- Membaca isi file
    local content = read_file(filename)
    if content then
        -- Teks yang ingin dihapus
        local text_to_remove = world.."\n" -- Menambahkan newline (\n) karena kita ingin mencocokkan baris secara penuh
        
        -- Menghapus teks tertentu dari isi file
        local modified_content = string.gsub(content, text_to_remove, "")
       
        -- Menulis kembali isi file
        if write_file(filename, modified_content) then
            print("Teks berhasil dihapus dari file.")
        else
            print("Gagal menulis ke file.")
        end
    else
        print("File tidak ditemukan atau tidak dapat dibaca.")
    end
end

function string.split(inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    local t = {}
    for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
        table.insert(t, str)
    end
    return t
end

function shuffleWorld(world)
    -- Nama file yang akan diubah
    local filename = config["worldListPNB"]
    
    -- Membaca isi file
    local content = read_file(filename)
    if content then
        -- Split content into lines
        local lines = {}
        for line in string.gmatch(content, "[^\r\n]+") do
            table.insert(lines, line)
        end

        -- Find and remove the line that matches the world
        local index_to_remove = nil
        for i, line in ipairs(lines) do
            if line == world then
                index_to_remove = i
                break
            end
        end

        if index_to_remove then
            table.remove(lines, index_to_remove)
            table.insert(lines, world) -- Add it to the end of the list
        end

        -- Combine the lines back into a single string
        local modified_content = table.concat(lines, "\n") .. "\n"

        -- Menulis kembali isi file
        if write_file(filename, modified_content) then
            print("Teks berhasil dipindahkan ke baris terakhir dari file.")
        else
            print("Gagal menulis ke file.")
        end
    else
        print("File tidak ditemukan atau tidak dapat dibaca.")
    end
end


function read(filename)
    local file = io.open(filename, "r")
    if not file then return "", "" end

    local lines = {}
    for line in file:lines() do
        table.insert(lines, line)
    end
    file:close()

    local cray = lines[1]
    local nino1, nino2 = "", ""
    if cray then
        nino1, nino2 = cray:match("([^|]*)|?(.*)")
        table.remove(lines, 1)
    end

    file = io.open(filename, "w")
    if file then
        for _, line in ipairs(lines) do
            file:write(line .. "\n")
        end
        if cray then
            file:write(cray .. "\n")
        end
        file:close()
    end

    return nino1, nino2
end

local GetBot = function(bot)
    local status = getBot(bot).status
    local statusNaming = {
        [BotStatus.offline] = "Offline",
        [BotStatus.online] = "Online",
        [BotStatus.account_banned] = "Account Banned",
        [BotStatus.location_banned] = "Location Banned",
        [BotStatus.server_overload] = "Server Overload",
        [BotStatus.too_many_login] = "Too Many Login",
        [BotStatus.maintenance] = "Maintenance",
        [BotStatus.version_update] = "Version Update",
        [BotStatus.server_busy] = "Server Busy",
        [BotStatus.error_connecting] = "Error Connecting",
        [BotStatus.logon_fail] = "Login Failed",
        [BotStatus.http_block] = "HTTP Blocked",
        [BotStatus.wrong_password] = "Wrong Password",
        [BotStatus.advanced_account_protection] = "Advanced Account Protection",
        [BotStatus.bad_name_length] = "Bad Name Length",
        [BotStatus.invalid_account] = "Invalid Account",
        [BotStatus.guest_limit] = "Guest Limit",
        [BotStatus.changing_subserver] = "Changing Subserver",
        [BotStatus.captcha_requested] = "Captcha",
        [BotStatus.mod_entered] = "Mod Entered",
        [BotStatus.high_load] = "High Load",
        [BotStatus.bad_gateway] = "Bad Gateway" ,
        [BotStatus.server_issue] = "Server Issue" ,
        [BotStatus.retrieving_token] = "Retrieving Token" ,
        [BotStatus.player_entered] = "Player Entered",
        [BotStatus.getting_server_data] = "Getting Server Data",
        [BotStatus.bypassing_server_data] = "Bypassing Server Data",
    }
    return statusNaming[status] or "Loading"
end

function maladyStatus(bot)
    local status = getBot(bot).malady
    local statusNaming = {
        [0] = "None",
        [1] = "Torn Punching Muscle",
        [2] = "Gem Cuts",
        [3] = "Chicken Feet",
        [4] = "Grumbleteeth",
        [5] = "Broken Heart",
        [6] = "Chaos Infection",
        [7] = "Moldy Guts",
        [8] = "Brainworms",
        [9] = "Lupus",
        [10] = "Ecto-Bones",
        [11] = "Fatty Liver",
    }
    return statusNaming[status] or "?"
end

function queryInsert(status)
    -- Set the custom status
    print(string.format(
        '[%d] %s',
        indexBot, status
        )
    )
    bot.custom_status = string.format(
        '[LEVELING] %s', status
    )
end

function onVarSearchTutorial(variant, netid)
    if variant:get(0):getString() == "OnRequestWorldSelectMenu" and variant:get(1):getString():find("Your Worlds") then
        local text = variant:get(1):getString()
        local lines = {}
        for line in text:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end
        for i, value in ipairs(lines) do
            if i == 3 then
                kalimat = lines[3]
                local nilai = kalimat:match("|([a-zA-Z0-9%s]+)|"):gsub("|", ""):gsub("%s", "")
                print(bot.name.." World PNB in "..nilai)
                worldPNB = nilai
            end
        end
    end
end

function onVarCheckQuest(var, netid)
    if var:get(0):getString() == "OnDialogRequest" then
        local text = var:get(1):getString()
        local lines = {}
        for line in text:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end
        for _,value in ipairs(lines) do
            if value:find("add_button|questselect") then
                canSelectQuest = true
            end
        end
    end
end

function tileDrop(x,y,num)
    local count = 0
    local stack = 0
    for _,obj in pairs(getObjects()) do
        if math.floor((obj.x + 10) / 32) == x and math.floor((obj.y + 10) / 32) == y then
            count = count + obj.count
            stack = stack + 1
        end
    end
    if stack < 20 and count <= (4000 - num) then
        return true
    end
    return false
end

function botInfo(url, status)
    webhook = Webhook.new(url)
    webhook.username = "Notification"
    webhook.content = status
    webhook:send()
end

function formatInt(number)
    local i, j, minus, int, fraction = tostring(number):find('([-]?)(%d+)([.]?%d*)')
    int = int:reverse():gsub("(%d%d%d)", "%1,")
    return minus .. int:reverse():gsub("^,", "") .. fraction
end

function buyClothes()
    local currentClothes = {}
    for _,inventory in pairs(bot:getInventory():getItems()) do
        if getInfo(inventory.id).clothing_type ~= 0 then
            table.insert(currentClothes,inventory.id)
        end
    end
    sleep(100)
    if #currentClothes < 20 then
        queryInsert("Buying Clothes")
        bot:sendPacket(2,"action|buy\nitem|rare_clothes")
        sleep(2500)
        for _,num in pairs(bot:getInventory():getItems()) do
            if getInfo(num.id).clothing_type ~= 0 then
                if num.id ~= 3934 and num.id ~= 3932 then
                    bot:wear(num.id)
                    sleep(500)
                end
            end
        end
    end
end

function nukeWorldInfo(url, world, door, status)
    local str = "======================================\nWorld : " .. world .. "|" .. door .. "\nStatus :  " .. status .. " @everyone\n======================================"

    if string.find(url, ".txt") then
        -- Jika URL mengandung ".txt", buka file untuk append
        local file = io.open(url, "a") -- Use "a" to append instead of "w+"
        if file then
            file:write(str)
            file:close()
        else
            print("Gagal membuka file: " .. url)
        end
    elseif string.find(url, "discord") then
        local webhook = Webhook.new(url)
        webhook.username = bot.name
        webhook.avatar_url = "https://cdn.discordapp.com/attachments/1058476002050850827/1271789959203917928/ItemSprites_1.png?ex=66b89e32&is=66b74cb2&hm=8976f3d28195c4e278d264965f9db1bc03db1e08d8a94772606b08048e80013f&"
        webhook.embed1.use = true
        webhook.embed1.title = "Status Info"
        webhook.embed1.description = "```" .. status .. "```"
        webhook.embed1.color = 0x6a5acd --embed color

        webhook.embed1:addField("Name", bot.name, true)
        webhook.embed1:addField("Gems", bot.gem_count, true)
        webhook.embed1:addField("Status", GetBot(bot.name) .. " (" .. bot:getPing() .. ")", true)
        webhook.embed1:addField("World", world .. " (" .. bot.x .. ":" .. bot.y ..")", true)
        webhook.embed1:addField("Level", "Lv. ".. bot.level, true)
        webhook.embed1:addField("Age", bot:getAge() .. " days", true)
        webhook.embed1:addField("Time world", displayWaktu(), false)

        webhook:send()
    end
end

function displayPack(url,id,value)
    local webhook = Webhook.new(url)
    webhook.username = 'Pack Information'
    webhook.avatar_url = "https://cdn.discordapp.com/attachments/1058476002050850827/1271789959203917928/ItemSprites_1.png?ex=66b89e32&is=66b74cb2&hm=8976f3d28195c4e278d264965f9db1bc03db1e08d8a94772606b08048e80013f&"
    webhook.embed1.use = true
    webhook.embed1.title = "PACK INFORMATION"
    webhook.embed1.description = "Last update : <t:"..os.time()..":R>\n" .. value
    webhook.embed1.color = 0x6a5acd --embed color

    webhook:edit(id)
end

function OnVariantList(variant, netid)
    if variant:get(0):getString() == "OnConsoleMessage" then
        if variant:get(1):getString():lower():find("inaccessible") or variant:get(1):getString():lower():find("lower") then
            warpStatus = variant:get(1):getString()
            nuked = true
        end
        if variant:get(1):getString():lower():find("high") then
            warpStatus = variant:get(1):getString()
            nuked = true
        end
    end
end

function warp(world,id,check,checkCCTV)
    cok = 0
    nuked = false
    addEvent(Event.variantlist, OnVariantList)
    sleep(100)
    queryInsert("Entering " .. world)
    sleep(100)
    while not bot:isInWorld(world:upper()) and not nuked do
        if bot.status == BotStatus.online and bot:getPing() == 0 then
            bot:disconnect()
            sleep(1000)
        end
        while bot.status ~= BotStatus.online do
            sleep(1000)
            if bot.status == BotStatus.account_banned then
                bot:stopScript()
            end
        end
        if id ~= "" then
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0")
        else
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
        end
        listenEvents(5)
        repeat
            sleep(config["interval"]["warp"])
            cok = cok + 1
            if cok % 10 == 0 and not bot:isInWorld(world:upper()) then
                queryInsert("Reentering World")
                sleep(5000)
                break
            end
            if cok % 50 == 0 and not bot:isInWorld(world:upper()) then
                queryInsert("Failed to enter world")
                sleep(100)
                bot:disconnect()
                sleep(5000)
                break
            end
        until bot:isInWorld(world:upper()) or nuked or (bot:getPing() <= 200)
    end
    if id ~= "" and getTile(bot.x,bot.y).fg == 6 and not nuked then
        cok = 0
        while getTile(bot.x,bot.y).fg == 6 and not nuked do
            while bot.status ~= BotStatus.online or bot:getPing() == 0 do
                sleep(1000)
                while bot.status == BotStatus.account_banned do
                    bot.auto_reconnect = false
                    bot:stopScript()
                end
            end
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0")
            sleep(5000)
            cok = cok + 1
            if cok == 5 and check then
                nuked = true
            end
        end
        if getTile(bot.x,bot.y).fg == 6 then
            nukeWorldInfo(config["webhook"]["world"], world, id, "INVALID_DOOR")
            sleep(100)
            nuked = true
        end
    end
    sleep(100)
    removeEvent(Event.variantlist)

    if checkCCTV then
        local intruder = checkIntruder()
        if intruder.status then
            nukeWorldInfo(config["webhook"]["info"], world, id, "INTRUDER DETECTED!\nTile Name : "..intruder.name.."\nPosition : "..intruder.x..":"..intruder.y)
            sleep(2500)
        end
    end
end

function displayBotList()
    local configWebhook = config["webhook"]["bot"]
    local webhook = Webhook.new(configWebhook["url"])
    webhook.username = "Chaos Automation"
    
    local embed = webhook.embed1
    embed.use = true
    embed.title = "BOT INFORMATION"
    embed.description = "Last update : <t:"..os.time()..":R>\n"
    embed.color = 0x6a5acd -- embed color
    
    local botList = getBots()
    if #botList <= 10 then
        for index, client in pairs(botList) do
            local stringStatus = (client.status == BotStatus.online) and "<:emoji_94:1035820949242646679>" or "<:emoji_95:1035820971292114964>"
            embed:addField(string.format(
                ':farmer: [%d] %s',
                index, client.name
            ), string.format(
                'Status : %s %s\nWorld : %s\nGems : %s\nLevel / Age : Lv. %d / %s days\nMalady : %s',
                GetBot(client.name), stringStatus, client:getWorld().name, formatInt(client.gem_count), client.level, client:getAge(), maladyStatus(bot.name)
            ), true) -- field.inline simplified
        end
    else
        local online, offline, banned = 0, 0, 0

        for _, client in pairs(botList) do
            if client.status == BotStatus.online then
                online = online + 1
            elseif client.status == BotStatus.account_banned then
                banned = banned + 1
            else
                offline = offline + 1
            end
        end

        embed:addField("<:emoji_94:1035820949242646679> Online", online, true)
        embed:addField("<:emoji_95:1035820971292114964> Offline", offline, true)
        embed:addField("<:emoji_banned:1035820983456614912> Banned", banned, true)
    end
    webhook:edit(configWebhook["id"])
end

function reconnect(world,id,x,y)
    local timeNow = os.date("*t")
    if timeNow.hour == 11 then
        done0 = false
        done1 = false
        done2 = false
    end
    while bot:getPing() >= 200 do
        sleep(100)
    end
    -- if config["autoRest"]["enable"] then
    --     local isResting = os.time() - uptime
    --     local nowResting = math.floor(isResting % 86400 % 3600 / 60)

    --     if nowResting >= config["autoRest"]["interval"] then
    --         if config["autoRest"]["disconnectRest"] then
    --             goExit()
    --             sleep(100)
    --         end

    --         queryInsert("Resting")
    --         sleep(100)

    --         bot.auto_reconnect = false
    --         sleep(100)

    --         bot:disconnect()
    --         sleep(config["autoRest"]["duration"] * 1000)
    --     end
    -- end
    if bot:isResting() then
        while bot:isResting() do
            sleep(1000)
        end
    end
    if bot.status == BotStatus.mod_entered then
        botInfo(config["webhook"]["info"], bot.name.." ["..indexBot.."] Mod entered!.")
        for _,botz in pairs(getBots()) do
            botz.auto_reconnect = false
            botz:disconnect()
            sleep(100)
        end
        sleep(60 * 60000)
        for _,botz in pairs(getBots()) do
            botz.auto_reconnect = true
            sleep(100)
        end
    end
    if bot:getWorld().name ~= world and bot.status == BotStatus.online then
        sleep(2000)
        bot:disconnect()
        sleep(1000)
    end
    if getTile(bot.x,bot.y).fg == 6 and bot.x == x and bot.y == y then
        local botIsStuck = true
        queryInsert("Stuck white door")
        sleep(1000)
        warp(world,id)
        sleep(1000)
    end
    if bot.status ~= BotStatus.online or bot:getPing() == 0 then
        sleep(100)
        queryInsert("Disconnected")
        while bot.status ~= BotStatus.online or bot:getPing() == 0 do
            sleep(1500)
            if bot.status == BotStatus.account_banned then
                botInfo(config["webhook"]["info"], bot.name.." ["..indexBot.."] is banned.")
                bot.auto_reconnect = false
                bot:stopScript()
            end
            if bot.status == BotStatus.location_banned then
                bot:connect()
                sleep(1000)
            end
        end
        sleep(100)
        warp(world,id)
        sleep(100)
        if x and y and (bot.x ~= x or bot.y ~= y) then
            bot:findPath(x,y)
            sleep(1000)
        end
        sleep(100)
        uptime = os.time()
        sleep(100)
        bot:say("/status")
        sleep(100)
        queryInsert("Connected")
        if botIsStuck and not getTile(bot.x,bot,y).fg == 6 then
            queryInsert('Success getting out')
            sleep(100)
        end
    end
end

function activeWorld(world)
    local seperateData = string.split(world, "|")
    return {name = seperateData[1] or "", door = seperateData[2] or ""}
end

function storeSeed(world)
    bot.auto_collect = false
    queryInsert("Storing Seeds")

    local selectWorld = config["storageSeedList"][math.random(1, #config["storageSeedList"])]
    local storageInfo = activeWorld(selectWorld)

    warp(storageInfo.name, storageInfo.door, true, true)
    sleep(100)
    
    if not nuked and bot:isInWorld(storageInfo.name:upper()) then
        for _,tile in pairs(bot:getWorld():getTiles()) do
            reconnect(storageInfo.name, storageInfo.door)
            if tile.y > 2 and tile.y < 25 and tile.x > 1 and tile.x < 98 then
                if tileDrop(tile.x,tile.y,100) then
                    bot:findPath(tile.x + 1,tile.y)
                    bot:setDirection(true)
                    sleep(100)
                    if findItem(config["itmSeed"]) > 100 then
                        bot:drop(config["itmSeed"], findItem(config["itmSeed"]))
                        reconnect(storageInfo.name, storageInfo.door, tile.x + 1, tile.y)
                    end
                    if findItem(config["itmSeed"]) <= 100 then
                        break
                    end
                end
            end
        end
    else
        if nuked then
            nukeWorldInfo(config["webhook"]["seed"], storageInfo.name, storageInfo.door, (warpStatus.." (SEED)" or "NUKED (SEED)"))
            sleep(5000)
        end
    end
    sleep(100)
    if config["claimGoals"]["enable"] then
        if not done0 or not done1 or not done2 then
            claimGoals(config["claimGoals"]["world"], config["claimGoals"]["doorId"])
            sleep(100)
            takeMagplant()
            sleep(100)
        end
    end
    warp(world,doorFarm)
    sleep(100)
    bot.auto_collect = true
    queryInsert("Success Storing Seeds")
end

function clear(world)
    for _,item in pairs(bot:getInventory():getItems()) do
        if not includesNumber(config["whiteList"], item.id) and findItem(item.id) >= 100 and bot:isInWorld() then
            bot:trash(item.id, findItem(item.id))
            sleep(500)
        end
    end
end

function goExit()
    while bot:getWorld().name ~= "EXIT" do
        if bot.status == BotStatus.online and bot:getPing() == 0 then
            bot:disconnect()
            sleep(1000)
        end
        while bot.status ~= BotStatus.online do
            sleep(1000)
            if bot.status == BotStatus.account_banned then
                bot:stopScript()
            end
        end
        bot:sendPacket(3,"action|quit_to_exit")
        sleep(7000)
    end
end

function checkTutorial()
    goExit()
    sleep(100)
    worldPNB = ""
    sleep(100)
    addEvent(Event.variantlist, onVarSearchTutorial)
    while worldPNB == "" and bot:getWorld().name == "EXIT" do
        bot:sendPacket(3,"action|world_button\nname|_16")
        listenEvents(5)
        sleep(2000)
    end
    sleep(100)
    removeEvent(Event.variantlist)
    sleep(100)
end

function pnbTutorial()
    warp(worldPNB,"",true,true)
    sleep(100)
    if not nuked and bot:getWorld().name == worldPNB and bot:getWorld():hasAccess(bot.x-1,bot.y) > 0 then
        if growscan(226) == 0 then
            if findItem(226) == 0 then
                if bot.gem_count > 2000 then
                    while findItem(226) == 0 and bot.gem_count > 2000 do
                        bot:buy("signal_jammer")
                        sleep(200)
                        reconnect(worldPNB,"")
                    end
                end
            end
            while findItem(226) >= 1 and getTile(bot.x, bot.y -2).fg == 0 do
                place(226,0,-2)
                sleep(100)
            end
        end
        while not checkActiveJammer() and getTile(bot.x, bot.y -2).fg == 226 do
            punch(0,-2)
            sleep(500)
        end
        if findItem(config["itmId"]) >= config["tileNumber"] and bot:getWorld().name == worldPNB:upper() and bot:getWorld():hasAccess(bot.x-1,bot.y) > 0 then
            ex = bot.x
            ye = bot.y
            bot.auto_collect = true
            while findItem(config["itmId"]) > config["tileNumber"] and findItem(config["itmSeed"]) <= 190 and bot:getWorld().name == worldPNB:upper() do
                for i,player in pairs(bot:getWorld():getPlayers()) do
                    if player.netid ~= getLocal().netid and player.name:upper() ~= config["whiteListOwner"]:upper() then
                        bot:say("/ban " .. player.name)
                        sleep(1000)
                    end
                end
                while tilePlace(ex,ye) and bot:getWorld().name == worldPNB do
                    for _,i in pairs(tileBreak) do
                        if getTile(ex,ye + i).fg == 0 and getTile(ex,ye + i).bg == 0 then
                            place(config["itmId"],0,i)
                            sleep(config["interval"]["place"])
                            reconnect(worldPNB,"",ex,ye)
                        end
                    end
                end
                while tilePunch(ex,ye) and bot:getWorld().name == worldPNB do
                    for _,i in pairs(tileBreak) do
                        if getTile(ex,ye + i).fg ~= 0 or getTile(ex,ye + i).bg ~= 0 then
                            punch(0,i)
                            sleep(config["interval"]["punch"])
                            reconnect(worldPNB,"",ex,ye)
                        end
                    end
                end
            end
        end
    elseif bot:isInWorld() and bot:getWorld():hasAccess(bot.x-1,bot.y) == 0 then
        checkTutorial()
    end
end

function readLineFile(name)
    local temporary = {}
    local file = io.open(name, "r")
    if file then
        for line in file:lines() do
            table.insert(temporary, line:upper())
        end
    end
    return temporary
end

function readBreakWorld(index)
    local checkWorld = readLineFile(config["worldListPNB"])
    if index < 1 or index > #checkWorld then
        return "", ""
    end

    local world, door = checkWorld[index]:match("([^|]*)|?(.*)")
    return world or "", door or ""
end

function pnbOtherWorld()
    ::RETRY_JOIN_PNB::
    worldBreak, doorBreak = readBreakWorld(indexBot)
    solveMalady(true,worldBreak,doorBreak)

    if worldBreak == "" then
        bot:stopScript()
        botInfo(config["webhook"]["info"], bot.name.." ["..indexBot.."] can't read file inside pnb otherworld!.")
    end

    warp(worldBreak,doorBreak,true,true)
    if nuked and string.find(warpStatus, "inaccessible") then
        deleteNuke(worldBreak .. '|' .. doorBreak)
        sleep(10000)
        goto RETRY_JOIN_PNB
    end
    -- if nuked and string.find(warpStatus, "high") then
    --     shuffleWorld(worldBreak .. '|' .. doorBreak)
    --     sleep(10000)
    --     goto RETRY_JOIN_PNB
    -- end

    if bot:isInWorld(worldBreak:upper()) then
        if findItem(config["itmId"]) >= config["tileNumber"] and bot:getWorld().name == worldBreak:upper() then
            ex = 6
            ye = 3
            sleep(100)
            bot:findPath(ex,ye)
            sleep(100)
            bot.auto_collect = true
            while findItem(config["itmId"]) > config["tileNumber"] and findItem(config["itmSeed"]) <= 190 and bot.x == ex and bot.y == ye and bot:getWorld().name == worldBreak:upper() do
                if bot.x ~= ex and bot.y ~= ye then
                    bot:findPath(ex, ye)
                    sleep(100)
                end
                if not bot:isInWorld(worldBreak:upper()) or getTile(bot.x, bot.y).fg == 6 then
                    bot:warp(worldBreak .. '|' .. doorBreak)
                    sleep(5000)
                end
                while tilePlace(ex,ye - 1) do
                    for _,i in pairs(tileBreak) do
                        if getTile(ex + i,ye - 1).fg == 0 then
                            place(config["itmId"],i,-1)
                            sleep(config["interval"]["place"])
                            reconnect(worldBreak,doorBreak,ex,ye)
                        end
                    end
                end
                while tilePunch(ex,ye - 1) do
                    for _,i in pairs(tileBreak) do
                        if getTile(ex + i,ye - 1).fg ~= 0 then
                            punch(i,-1)
                            sleep(config["interval"]["punch"])
                            reconnect(worldBreak,doorBreak,ex,ye)
                        end
                    end
                end
                reconnect(worldBreak,doorBreak,ex,ye)
                sleep(30)
            end
            sleep(1000)
        end
    end
end

function checkItemStorage()
    for _,item in pairs(config["event"]["list"]) do
        if findItem(item["id"]) >= item["count"] then
            return true
        end
    end
    return false
end

function autoWear(world)
    if config["autoWear"]["enable"] then
        if config["autoWear"]["buy"]["enable"] then
            while bot:isInWorld() and bot.gem_count >= config["autoWear"]["buy"]["price"] and findItem(config["autoWear"]["id"]) == 0 do
                bot:buy("mooncake_mag")
                sleep(500)
                reconnect(world,doorFarm)
            end
        end
        while bot:isInWorld() and not bot:getInventory():getItem(config["autoWear"]["id"]).isActive and findItem(config["autoWear"]["id"]) > 0 do
            bot:wear(config["autoWear"]["id"])
            sleep(200)
            reconnect(world,doorFarm)
        end
    end
end

function OnCheckSurgeryError(var,netid)
    if var:get(0):getString() == "OnDialogRequest" then
        local text = var:get(1):getString()
        local lines = {}
        for line in text:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end
        surgeryDialogPopup = false
        for _,str in ipairs(lines) do
            if str:find("autoSurgeonUi") then
                surgeryDialogPopup = true
                break
            end
        end
        unlistenEvents()
    end
end

function buyLockForSurgery(amount)
    for _ = 1, amount do
        if bot.status == BotStatus.online and bot:isInWorld() and findItem(242) < amount and bot.gem_count >= 2000 then
            bot:buy("world_lock")
            sleep(1200)
        end
    end
end

function queueWorld(destination)
    local numPlayer = 0
    for _,client in pairs(getBots()) do
        if client.name ~= bot.name and client:getWorld().name == destination:upper() then
            numPlayer = numPlayer + 1
        end
    end
    return numPlayer
end

function takeVile()
    local vileList = {
        8538, -- Chaos Infection
        8540, -- Moldy Guts
        8542, -- Brainworms
        8544, -- Lupus
        8546, -- Ecto-Bones
        8548, -- Fatty Liver
    }
    for _,vile in pairs(vileList) do
        for _,obj in ipairs(getObjects()) do
            if obj.id == vile and bot:findPath(math.floor((obj.x + 10) / 32) + 1,math.floor((obj.y + 10) / 32)) then
                sleep(200)
                bot:collectObject(obj.oid, 3)
                sleep(200)
            end
        end
        if findItem(vile) > 0 then
            return {status = true, id = vile}
        end
    end
    return {status = false, id = 0}
end

function solveMalady(checkStatus,world,door)
    if config["malady"]["enable"] then
        if checkStatus and bot.status == BotStatus.online and bot:isInWorld() then
            bot:say("/status")
            sleep(1000)
        end
        if (bot.malady == 1 or bot.malady == 2) and (bot.gem_count > 7000 or findItem(242) >= 3) then
            buyLockForSurgery(3)
            sleep(100)

            currentMalady = bot.malady
            sleep(100)

            local selectWorld = config["malady"][currentMalady]["world"][math.random(1, #config["malady"][currentMalady]["world"])]
            local storage = activeWorld(selectWorld)

            warp(storage.name,storage.door,false,false)
            sleep(100)

            if not nuked and bot:isInWorld(storage.name:upper()) then
                if bot:findPath(config["malady"][currentMalady]["x"],config["malady"][currentMalady]["y"]) then
                    sleep(1000)
                    addEvent(Event.varlist, OnCheckSurgeryError)
                    sleep(1000)
                    if bot.status == BotStatus.online then
                        bot:wrench(config["malady"][currentMalady]["x"], config["malady"][currentMalady]["y"])
                        listenEvents(5)
                    end
                    if surgeryDialogPopup and findItem(242) >= 3 then
                        if bot.status == BotStatus.online then
                            bot:sendPacket(2,"action|dialog_return\ndialog_name|autoSurgeonUi\nbuttonClicked|purchaseCureBtn")
                            sleep(1000)
                        end
                        if bot.status == BotStatus.online then
                            bot:sendPacket(2,"action|dialog_return\ndialog_name|autoSurgeonCurePurchaseUi\nbuttonClicked|purchaseCureBtn")
                            sleep(1000)
                        end
                    end
                end
            end
            bot:say("/status")
            sleep(100)
        end
        if bot.malady == 0 then
            if config["malady"]["infect"] then
                warp(world,door)
                sleep(100)
                if bot:isInWorld() then

                    local spam = bot.auto_spam
                    local messages = spam.messages -- Spam Message List

                    for i, message in pairs(config["chatList"]) do
                        messages:add(message)
                    end

                    local malady = bot.auto_malady
                    malady.enabled = true
                    malady.auto_surgery_station = false
                    malady.auto_vial = false
                    malady.auto_chicken_feet = true
                    malady.auto_grumbleteeth = true
                    malady.auto_refresh = false

                    queryInsert("Getting Malady")

                    while bot.malady == 0 do
                        while bot.status ~= BotStatus.online or bot:getPing() == 0 do
                            sleep(1000)
                            while bot.status == BotStatus.account_banned do
                                bot.auto_reconnect = false
                                bot:stopScript()
                            end
                        end
                        if bot:isInWorld() and bot.status == BotStatus.online then
                            bot:say("/status")
                            sleep(100)
                        end
                        sleep(math.random(5, 60) * 1000)
                    end
                    malady.enabled = false
                end
                warp(world,door)
                sleep(100)
            else
                bot.auto_collect = false
                queryInsert("Taking vile")
            
                local selectWorld = config["storageVileList"][math.random(1, #config["storageVileList"])]
                local storage = activeWorld(selectWorld)
            
                warp(storage.name, storage.door, true, true)
                sleep(100)
                
                if not nuked and bot:isInWorld(storage.name:upper()) then
                    local vileList = {
                        8538, -- Chaos Infection
                        8540, -- Moldy Guts
                        8542, -- Brainworms
                        8544, -- Lupus
                        8546, -- Ecto-Bones
                        8548, -- Fatty Liver
                    }
                    while findItem(config["malady"]["id"]) == 0 do
                        for _,obj in pairs(getObjects()) do
                            reconnect(storage.name, storage.door)
                            sleep(100)
                            if obj.id == config["malady"]["id"] and bot:findPath(math.floor((obj.x + 10) / 32) + 1,math.floor((obj.y + 10) / 32)) then
                                sleep(200)
                                bot:collectObject(obj.oid, 3)
                                sleep(200)
                            end
                            if findItem(config["malady"]["id"]) > 0 then
                                break
                            end
                        end
                        reconnect(storage.name, storage.door)
                        sleep(100)
                    end
                    sleep(500)
                    bot:setDirection(true)
                    sleep(500)
                    while findItem(config["malady"]["id"]) > 1 do
                        bot:drop(config["malady"]["id"], findItem(config["malady"]["id"]) - 1)
                        sleep(200)
                        reconnect(storage.name, storage.door)
                    end
                    sleep(500)
                    while findItem(config["malady"]["id"]) == 1 and bot.malady == 0 do
                        bot:findPath(math.random(3,50),bot.y)
                        sleep(500)
                        bot:use(config["malady"]["id"])
                        sleep(500)
                        bot:say("/status")
                        sleep(500)
                        reconnect(storage.name, storage.door)
                    end
                    if findItem(config["malady"]["id"]) == 0 or bot.malady ~= 0 then
                        bot:say("used crotttt")
                        sleep(1000)
                    end
                    displayPack(config["malady"]["webhook"]["url"], config["malady"]["webhook"]["id"], infoPack())
                    sleep(100)
                end
                if bot.status == BotStatus.online and bot:isInWorld() then
                    bot:say("/status")
                    sleep(1000)
                end
                warp(world,door)
                sleep(100)
                bot.auto_collect = true
                sleep(100)
            end
        end
    end
end


function pnb(world)
    if bot.level >= 1 then
        queryInsert("Breaking Block's")
        sleep(100)
        if bot:isInWorld() then
            if config["randomChat"] then
                local chatBot = config["chatList"][math.random(1, #config["chatList"])]
                bot:say(chatBot)
                sleep(1000)
                local chatBot = config["emoteList"][math.random(1, #config["emoteList"])]
                bot:say(chatBot)
                sleep(1000)
            end
            if findItem(config["itemHand"]) > 0 then
                bot:wear(config["itemHand"])
                sleep(100)
            end
        end
        if config["pnbInTutorial"] then
            pnbTutorial()
        elseif config["differentWorldPNB"] then
            pnbOtherWorld()
        else
            solveMalady(true,world)
            sleep(100)
            if findItem(config["itmId"]) >= config["tileNumber"] and bot:getWorld().name == world:upper() then
                if not config["customTile"] then
                    ex = bot.x
                    ye = bot.y
                else
                    ex = math.random(3, 90)
                    ye = config["customY"]
                end
                sleep(100)
                bot:findPath(ex,ye)
                sleep(100)
                bot.auto_collect = true
                sleep(100)
                durasiPNB = os.time()
                sleep(100)
                while findItem(config["itmId"]) > config["tileNumber"] and findItem(config["itmSeed"]) <= 190 and bot.x == ex and bot.y == ye do
                    while tilePlace(ex,ye - 1) and bot.x == ex and bot.y == ye do
                        for _,i in pairs(tileBreak) do
                            if getTile(ex + i,ye - 1).fg == 0 or getTile(ex + i,ye - 1).bg == 0 then
                                place(config["itmId"],i,-1)
                                sleep(config["interval"]["place"])
                                reconnect(world,doorFarm,ex,ye)
                            end
                        end
                    end
                    while tilePunch(ex,ye - 1) and bot.x == ex and bot.y == ye do
                        for _,i in pairs(tileBreak) do
                            if getTile(ex + i,ye - 1).fg ~= 0 or getTile(ex + i,ye - 1).bg ~= 0 then
                                punch(i,-1)
                                sleep(config["interval"]["punch"])
                                reconnect(world,doorFarm,ex,ye)
                            end
                        end
                    end
                end
                sleep(100)
                durasiPNB = os.time() - durasiPNB
                sleep(100)
                print("[" .. indexBot .. "]" .. " Durasi PNB : " .. math.floor(durasiPNB % 3600 / 60) .. " Minutes " .. math.floor(durasiPNB % 60) .. " Seconds")
                sleep(100)
            end
        end
        sleep(100)
        clear(world)
        sleep(100)
        if config["event"]["enable"] and checkItemStorage() then
            dropStorage(world)
            sleep(100)
        end
        if config["buyCloth"] and bot.gem_count >= (bot:getInventory():price() + 1000) then
            while bot:getInventory().slotcount < 86 and bot.gem_count >= bot:getInventory():price() do
                queryInsert("Upgrading Backpack x" .. bot:getInventory().slotcount)
                bot:buy("upgrade_backpack")
                sleep(1200)
                reconnect(world,doorFarm)
            end
            if bot:getInventory().slotcount >= 86 and bot.gem_count >= 3500 then
                buyClothes()
                sleep(100)
            end
        end
        warp(world,doorFarm)
        sleep(100)
        plant(world)
        sleep(100)
    end
end

function isItemInInventory(tableName, quantity)
    local amount = quantity or 1
    for _,name in pairs(tableName) do
        if findItem(name) >= amount then
            return true
        end
    end
    return false
end

function includesNumber(table, number)
    for _,num in pairs(table) do
        if num == number then
            return true
        end
    end
    return false
end

function dropStorage(world)
    bot.auto_collect = false
    queryInsert("Dropping Item Event")

    local storage = activeWorld(config["event"]["world"])
    warp(storage.name,storage.door,true,true)

    if not nuked and bot:isInWorld(storage.name:upper()) then
        for _,item in pairs(config["event"]["list"]) do
            for _,tile in pairs(getTiles()) do
                reconnect(storage.name,storage.door)
                if (tile.x >= 1 and tile.x <= 98) and (tile.y >= 1 and tile.y <= 25) and tileDrop(tile.x, tile.y, findItem(item["id"])) and findItem(item["id"]) >= 1 then
                    if bot:findPath(tile.x + 1, tile.y) then
                        sleep(100)
                        local countDrop = 0
                        while findItem(item["id"]) > 0 and tileDrop(tile.x,tile.y, findItem(item["id"])) do
                            bot:setDirection(true)
                            sleep(100)
                            bot:drop(item["id"], findItem(item["id"]))
                            sleep(500)
                            reconnect(storage.name,storage.door,tile.x + 1, tile.y)
                            if countDrop >= 5 then
                                break
                            else
                                countDrop = countDrop + 1
                            end
                        end
                    end
                end
                if findItem(item["id"]) == 0 then
                    break
                end
            end
            reconnect(storage.name,storage.door)
            sleep(100)
        end
        displayPack(config["event"]["webhook"]["url"], config["event"]["webhook"]["id"], infoPack())
        sleep(100)
    else
        if nuked then
            nukeWorldInfo(config["webhook"]["world"], storage.name,storage.door, (warpStatus.." (ITEM)" or "NUKED (ITEM)"))
        end
    end
    warp(world,doorFarm)
    sleep(100)
    bot.auto_collect = true
    queryInsert("Success Dropping Item")
end

function infoPack()
    local str = {}
    local growscan = bot:getWorld().growscan
    local objects = growscan:getObjects()

    for id, count in pairs(objects) do
        table.insert(str, getItemName(id).emote .. " " .. getInfo(id).name .. " : " .. formatInt(count))
    end

    return table.concat(str, "\n")
end

function isPlantable(tile)
    local tempTile = getTile(tile.x, tile.y + 1)
    if not tempTile.fg then 
        return false 
    end
    local collision = getInfo(tempTile.fg).collision_type
    return tempTile and ( collision == 1 or collision == 2 )
end

function plant(world)
    queryInsert("Planting Seed's")
    for _,tile in pairs(tilePath) do
        if getTile(tile.x,tile.y).fg == 0 and isPlantable(getTile(tile.x,tile.y)) and bot:getWorld():hasAccess(tile.x,tile.y) > 0 and findItem(config["itmSeed"]) > 0 and bot:getWorld().name == world:upper() then
            bot:findPath(tile.x,tile.y)
            for _, i in pairs(mode3Tile) do
                while getTile(tile.x + i,tile.y).fg == 0 and isPlantable(getTile(tile.x + i,tile.y)) and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 and findItem(config["itmSeed"]) > 0 and bot.x == tile.x and bot.y == tile.y and bot:getWorld().name == world:upper() do
                    place(config["itmSeed"],i,0)
                    sleep(math.random(config["interval"]["plant"] - 30,config["interval"]["plant"] + 30))
                    reconnect(world,doorFarm,tile.x,tile.y - 1)
                end
            end
        end
    end
end

function takePickaxe()
    bot.auto_collect = false
    sleep(100)
    queryInsert("Taking Pickaxe")
    sleep(100)
    warp(worldPickaxe, config["doorPickaxe"],true,true)
    sleep(100)
    if not nuked then
        while findItem(config["itemHand"]) == 0 do
            for _,obj in pairs(getObjects()) do
                reconnect(worldPickaxe, config["doorPickaxe"])
                if obj.id == config["itemHand"] then
                    bot:findPath(math.floor((obj.x + 10) / 32) + 1,math.floor((obj.y + 10) / 32))
                    sleep(100)
                    bot:collectObject(obj.oid, 3)
                    sleep(100)
                end
                if findItem(config["itemHand"]) > 0 then
                    break
                end
            end
            reconnect(worldPickaxe, config["doorPickaxe"])
            sleep(100)
        end
        sleep(100)
        bot:setDirection(true)
        sleep(100)
        while findItem(config["itemHand"]) > 1 do
            bot:drop(config["itemHand"], findItem(config["itemHand"]) - 1)
            sleep(500)
        end
        bot:wear(config["itemHand"])
        sleep(100)
        goExit()
        sleep(100)
    else
        if nuked then
            nukeWorldInfo(config["webhook"]["world"], worldPickaxe, config["doorPickaxe"], (warpStatus.." (PICKAXE)" or "NUKED (PICKAXE)"))
        end
    end
    if findItem(config["itemHand"]) >= 1 then
        queryInsert("Success Taking Pickaxe")
        sleep(100)
    else
        queryInsert("Failed Taking Pickaxe")
        sleep(100)
    end
end

function takeSeed(world)
    ::RETRY_TAKE::
    queryInsert("Taking Seed's")
    sleep(100)
    local storageInfo = activeWorld(config["storageSeedList"][storageIndex])
    warp(storageInfo.name,storageInfo.door,true,true)

    if not nuked then
        for _,obj in pairs(bot:getWorld():getObjects()) do
            reconnect(storageInfo.name, storageInfo.door)
            if obj.id == config["itmSeed"] then
                if bot:findPath(math.floor((obj.x + 10) / 32),math.floor((obj.y + 10) / 32)) then
                    sleep(100)
                    bot:collectObject(obj.oid, 3)
                    sleep(100)
                end
            end
            if findItem(config["itmSeed"]) > 0 then
                break
            end
        end
        sleep(100)
    else
        if nuked then
            nukeWorldInfo(config["webhook"]["seed"], storageInfo.name, storageInfo.door, (warpStatus.." (SEED)" or "NUKED (SEED)"))
        end
    end
    if findItem(config["itmSeed"]) == 0 then
        storageIndex = (storageIndex % #config["storageSeedList"]) + 1
        goto RETRY_TAKE
    end
    warp(world,doorFarm)
    sleep(100)
    queryInsert("Success Taking Seed's")
    sleep(100)
end

function harvest(world)
    autoWear(world)
    sleep(100)
    treeWorld[world] = 0
    if bot.level < config["freshBotLevel"] and config["freshBot"] then
        queryInsert("Reaching Level")
        sleep(100)
        for _,tile in pairs(tilePath) do
            reconnect(world,doorFarm)
            if getTile(tile.x,tile.y):canHarvest() and bot:isInWorld(world:upper()) and bot:getWorld():hasAccess(tile.x,tile.y) > 0 and bot.level < config["freshBotLevel"] and getBot().status == BotStatus.online then
                if bot:findPath(tile.x,tile.y) then
                    for _, i in pairs(mode3Tile) do
                        if getTile(tile.x + i,tile.y).fg == config["itmSeed"] and getTile(tile.x + i,tile.y):canHarvest() and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 then
                            treeWorld[world] = treeWorld[world] + 1
                            while getTile(tile.x + i,tile.y).fg == config["itmSeed"] and getTile(tile.x + i,tile.y):canHarvest() and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 and bot.x == tile.x and bot.y == tile.y do
                                punch(i,0)
                                sleep(math.random(config["interval"]["harvest"] - 30,config["interval"]["harvest"] + 30))
                                reconnect(world,doorFarm,tile.x,tile.y)
                            end
                        end
                    end
                    bot:collect(3)
                end
            end
            if bot.level >= config["freshBotLevel"] then
                break
            end
        end
        queryInsert("Cleaning Objects")
        sleep(100)
        for _,obj in pairs(getObjects()) do
            reconnect(world,doorFarm)
            if obj.id == config["itmId"] and getInfo(getTile(math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32)).fg).collision_type == 0 then
                if bot:findPath(math.floor((obj.x + 10) / 32),math.floor((obj.y + 10) / 32)) then
                    sleep(200)
                    bot:collect(3)
                    sleep(200)
                    reconnect(world,doorFarm,math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
                end
            end
            if findItem(config["itmId"]) >= 190 then
                pnb(world)
                sleep(100)
                if findItem(config["itmSeed"]) > 150 then
                    storeSeed(world)
                    sleep(100)
                end
                queryInsert("Cleaning Objects")
                sleep(100)
            end
        end
    end
    if bot.level >= config["freshBotLevel"] or not config["freshBot"] then
        for _,tile in pairs(tilePath) do
            reconnect(world,doorFarm)
            if getTile(tile.x,tile.y).fg == config["itmSeed"] and bot:isInWorld(world:upper()) and bot:getWorld():hasAccess(tile.x,tile.y) > 0 and (bot.level >= config["freshBotLevel"] or not config["freshBot"]) and bot.status == BotStatus.online then
                if getTile(tile.x,tile.y):canHarvest() and bot:findPath(tile.x,tile.y) then
                    for _, i in pairs(mode3Tile) do
                        if getTile(tile.x + i,tile.y).fg == config["itmSeed"] and getTile(tile.x + i,tile.y):canHarvest() and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 then
                            treeWorld[world] = treeWorld[world] + 1
                            while getTile(tile.x + i,tile.y).fg == config["itmSeed"] and getTile(tile.x + i,tile.y):canHarvest() and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 and bot.x == tile.x and bot.y == tile.y do
                                punch(i,0)
                                sleep(math.random(config["interval"]["harvest"] - 30,config["interval"]["harvest"] + 30))
                                reconnect(world,doorFarm,tile.x,tile.y)
                            end
                        end
                        while getTile(tile.x + i,tile.y).fg == config["itmId"] and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 and bot.x == tile.x and bot.y == tile.y and bot:getWorld().name == world:upper() do
                            punch(i,0)
                            sleep(math.random(config["interval"]["punch"] - 30,config["interval"]["punch"] + 30))
                            reconnect(world,doorFarm,tile.x,tile.y)
                        end
                    end
                    for _, i in pairs(mode3Tile) do
                        while getTile(tile.x + i,tile.y).fg == 0 and isPlantable(getTile(tile.x + i,tile.y)) and findItem(config["itmSeed"]) > 0 and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 and bot.x == tile.x and bot.y == tile.y and bot:getWorld().name == world:upper() do
                            place(config["itmSeed"],i,0)
                            sleep(math.random(config["interval"]["plant"] - 30,config["interval"]["plant"] + 30))
                            reconnect(world,doorFarm,tile.x,tile.y)
                        end
                    end
                    bot:collect(3)
                end
            end
            if findItem(config["itmId"]) >= 190 then
                pnb(world)
                sleep(100)
                if findItem(config["itmSeed"]) > 150 then
                    storeSeed(world)
                    sleep(100)
                end
                queryInsert("Harvesting Tree")
                sleep(100)
            end
        end
        if config["detectFloat"] then
            for _,obj in pairs(getObjects()) do
                reconnect(world,doorFarm)
                if obj.id == config["itmId"] and getInfo(getTile(math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32)).fg).collision_type == 0 then
                    if bot:findPath(math.floor((obj.x + 10) / 32),math.floor((obj.y + 10) / 32)) then
                        sleep(200)
                        bot:collect(3)
                        sleep(200)
                        reconnect(world,doorFarm,math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
                    end
                end
                if findItem(config["itmId"]) >= 190 then
                    pnb(world)
                    sleep(100)
                    if findItem(config["itmSeed"]) > 150 then
                        storeSeed(world)
                        sleep(100)
                    end
                    queryInsert("Cleaning Objects")
                    sleep(100)
                end
            end
        end
    end
    if config["autoFill"] then
        queryInsert("Filling Seeds")
        sleep(100)
        for _,tile in pairs(tilePath) do
            if findItem(config["itmSeed"]) == 0 then
                takeSeed(world)
                sleep(100)
            end
            if (tile.fg == 0 and tile.y ~= 0 and isPlantable(tile)) and bot:isInWorld(world:upper()) and bot:getWorld():hasAccess(tile.x,tile.y) > 0 then
                bot:findPath(tile.x,tile.y)
                for _, i in pairs(mode3Tile) do
                    while getTile(tile.x + i,tile.y).fg == 0 and isPlantable(getTile(tile.x + i,tile.y)) and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 and findItem(config["itmSeed"]) > 0 and bot.x == tile.x and bot.y == tile.y and bot:getWorld().name == world:upper() do
                        place(config["itmSeed"],i,0)
                        sleep(math.random(config["interval"]["plant"] - 30,config["interval"]["plant"] + 30))
                        reconnect(world,doorFarm,tile.x,tile.y)
                    end
                end
            end
        end
    end
end

function clearBlocks(world)
    queryInsert("Cleaning Blocks")
    sleep(100)
    for _,tile in ipairs(getTiles()) do
        reconnect(world,doorFarm)
        if (getTile(tile.x,tile.y).fg == config["itmId"] or getTile(tile.x,tile.y).bg == config["itmId"]) then
            bot:findPath(tile.x,tile.y)
            while (getTile(tile.x,tile.y).fg == config["itmId"] or getTile(tile.x,tile.y).bg == config["itmId"]) and bot.x == tile.x and bot.y == tile.y do
                punch(0,0)
                sleep(math.random(config["interval"]["punch"] - 30,config["interval"]["punch"] + 30))
                reconnect(world,doorFarm,tile.x,tile.y)
            end
        end
    end
end

function checkIntruder()
    local blacklist = {
        10258,  -- Pigeon
        1436,   -- Security Camera
        8246,   -- Starship Camera
    }
    for _,list in pairs(blacklist) do
        for _,tile in ipairs(getTiles()) do
            if tile.fg == list then
                return {
                    status = true, 
                    x = tile.x, 
                    y = tile.y, 
                    name = getInfo(tile.fg).name
                }
            end
        end
    end
    return {
        status = false, 
        x = 0, 
        y = 0, 
        name = "NONE"
    }
end

-- Generates a random string of uppercase letters
function randomLetter(length)
    local letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    local str = {}

    for i = 1, length do
        local index = math.random(1, #letters)
        str[i] = letters:sub(index, index)
    end

    return table.concat(str)
end

-- Joins random worlds and performs actions
function join()
    queryInsert("Clearing History")
    sleep(100)
    local worldsToJoin = {}

    if config["randomWorld"] then
        for _ = 1, 5 do
            table.insert(worldsToJoin, randomLetter(5))
        end
    end

    for _, world in ipairs(worldsToJoin) do
        warp(world, "",false,false)
        sleep(100)
        if not nuked and bot:isInWorld(world:upper()) then
            sleep(1000)
            bot:moveRight()
            sleep(1000)
            bot:say("/rate 1")
            sleep(1000)
        end
    end
end

function checkGoalCriteria(line)
    local searchTerms = {"Experience Goal:`", "Seed Goal:", "Gem Goal:`"}
    local validWords = {"Harvest", "Smash", "Plant", "Earn"}

    for _, searchTerm in ipairs(searchTerms) do
        local startIndex, endIndex = line:find(searchTerm)
        if startIndex then
            afterGoal = line:sub(endIndex + 1):match("^%s*([%a%d]+)")
            if afterGoal then
                for _, word in ipairs(validWords) do
                    if afterGoal == word then
                        return false
                    end
                end
            end
            return true
        end
    end
    return true
end

function onVarSearchGoals(var, netid)
    if var:get(0):getString() == "OnDialogRequest" then
        local text = var:get(1):getString()
        local lines = {}
        for line in text:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end
        finish0 = false
        finish1 = false
        finish2 = false
        skip0 = false
        skip1 = false
        skip2 = false
        local count = 0
        for _,value in ipairs(lines) do
            if value:find("Goal:") then
                if count == 0 then
                    skip0 = checkGoalCriteria(value)
                elseif count == 1 then
                    skip1 = checkGoalCriteria(value)
                elseif count == 2 then
                    skip2 = checkGoalCriteria(value)
                end
                count = count + 1
            end
            if value:find("add_button_with_icon|finish0") then
                finish0 = true
            end
            if value:find("add_button_with_icon|finish1") then
                finish1 = true
            end
            if value:find("add_button_with_icon|finish2") then
                finish2 = true
            end
            if value:find("add_button_with_icon|giveup0") then
                giveup0 = true
            end
            if value:find("add_button_with_icon|giveup1") then
                giveup1 = true
            end
            if value:find("add_button_with_icon|giveup2") then
                giveup2 = true
            end
        end
    end
end

function claimGoals(world,door)
    queryInsert("Claiming Goals")
    sleep(100)
    warp(world, door,true,false)
    sleep(7000)
    if not nuked and bot:isInWorld(world:upper()) then
        for _,tile in pairs(getTiles()) do
            if tile.fg == 3898 and bot:findPath(tile.x,tile.y + 2) then
                sleep(500)
                bot:wrench(tile.x,tile.y)
                sleep(1000)
                bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-2|\ndial|12345")
                sleep(1000)
                addEvent(Event.variantlist, onVarSearchGoals)
                bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|12345|\nbuttonClicked|chc1")
                listenEvents(5)
                sleep(1000)
                if finish0 and bot:isInWorld(world:upper()) then
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-4|\nbuttonClicked|finish0")
                    sleep(1000)
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-12|\nbuttonClicked|back")
                    sleep(1000)
                    done0 = true
                end
                if skip0 and giveup0 and bot:isInWorld(world:upper()) then
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-4|\nbuttonClicked|giveup0")
                    sleep(1000)
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-10|\ngoal|0||\nbuttonClicked|giveuptrue")
                    sleep(1000)
                    done0 = true
                end
                if not finish0 and not giveup0 then
                    done0 = true
                end
                if finish1 and bot:isInWorld(world:upper()) then
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-4|\nbuttonClicked|finish1")
                    sleep(1000)
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-12|\nbuttonClicked|back")
                    sleep(1000)
                    done1 = true
                end
                if skip1 and giveup1 and bot:isInWorld(world:upper()) then
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-4|\nbuttonClicked|giveup1")
                    sleep(1000)
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-10|\ngoal|1||\nbuttonClicked|giveuptrue")
                    sleep(1000)
                    done1 = true
                end
                if not finish1 and not giveup1 then
                    done1 = true
                end
                if finish2 and bot:isInWorld(world:upper()) then
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-4|\nbuttonClicked|finish2")
                    sleep(1000)
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-12|\nbuttonClicked|back")
                    sleep(1000)
                    done1 = true
                end
                if skip2 and giveup2 and bot:isInWorld(world:upper()) then
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-4|\nbuttonClicked|giveup2")
                    sleep(1000)
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|phonecall\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nnum|-10|\ngoal|2||\nbuttonClicked|giveuptrue")
                    sleep(1000)
                    done2 = true
                end
                if not finish2 and not giveup2 then
                    done2 = true
                end
                removeEvent(Event.variantlist)
                break
            end
        end
    end
    queryInsert("Success Claiming Goals")
    sleep(100)
end

function OnCheckMagplant(var)
    if var:get(0):getString() == "OnDialogRequest" then
        local text = var:get(1):getString()
        local lines = {}
        canTakeRemote = false
        for line in text:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end
        for _,value in pairs(lines) do
            if value:find("add_button|getplantationdevice|Get Remote|noflags|0|0|") then
                canTakeRemote = true
            end
        end
    end
end

function takeMagplant()
    magWorld = "PAPAEGG"
    magDoor = "BFG"

    while queueWorld(magWorld) >= 3 do
        queryInsert("[METHOD] Queueing in Magplant")
        while bot.status ~= BotStatus.online or bot:getPing() == 0 do
            sleep(1000)
            if bot.google_status == 3 or bot.google_status == 7 then
                bot:connect()
                sleep(1000)
            end
            while bot.status == BotStatus.account_banned do
                bot.auto_reconnect = false
                bot:stopScript()
            end
        end
        sleep(math.random(5,15) * 1000)
    end

    warp(magWorld,magDoor,true,false)
    sleep(100)

    if not nuked then
        for _,tile in pairs(getTiles()) do
            if tile.fg == 5638 and bot:findPath(tile.x,tile.y - 1) then
                addEvent(Event.varlist, OnCheckMagplant)
                sleep(1000)
                bot:wrench(tile.x,tile.y)
                listenEvents(5)
                if canTakeRemote and bot:isInWorld() then
                    bot:sendPacket(2,"action|dialog_return\ndialog_name|itemsucker\ntilex|"..tile.x.."|\ntiley|"..tile.y.."|\nbuttonClicked|getplantationdevice")
                    sleep(2000)
                end
            end
            if findItem(5640) == 1 then
                removeEvent(Event.varlist)
                break
            end
        end
    end
    goExit()
    sleep(100)
end

function checkFire()
    local hasFire = false
    local hasToxicWaste = false

    for _,tile in pairs(getTiles()) do
        if tile:hasFlag(4096) then
            hasFire = true
        end
        if tile.fg == 778 then
            hasToxicWaste = true
        end
        if hasFire and hasToxicWaste then
            return {fire = true, toxic = true}
        end
    end

    return {fire = hasFire, toxic = hasToxicWaste}
end

function OnVarSearchQuest(var, netid)
    if var:get(0):getString() == "OnDialogRequest" then
        local text = var:get(1):getString()
        local lines = {}
        for line in text:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end
        botCanStartQuest = false
        botFinishQuest = false
        for _,value in ipairs(lines) do
            if value:find("add_button|questselect") then
                botCanStartQuest = true
            elseif value:find("add_button|completequest") then
                botFinishQuest = true
            end
        end
    end
end

function roleQuest()
    addEvent(Event.variantlist, OnVarSearchQuest)

    if bot:isInWorld() then
        bot:say("/roles")
        listenEvents(5)

        if botCanStartQuest then
            bot:sendPacket(2, "action|dialog_return\ndialog_name|rolequestspage\nbuttonClicked|questselect")
            sleep(500)
            bot:sendPacket(2, "action|dialog_return\ndialog_name|rolequestselectpage\nbuttonClicked|startFarmerquest")
            sleep(500)
            bot:sendPacket(2, "action|dialog_return\ndialog_name|rolequestconfirm\nbuttonClicked|startFarmerquest")
            sleep(500)
        elseif botFinishQuest then
            bot:sendPacket(2, "action|dialog_return\ndialog_name|rolequestspage\nbuttonClicked|completequest")
            sleep(500)
        end
    end

    removeEvent(Event.variantlist)
end

while bot.status ~= BotStatus.online do
    bot.auto_reconnect = true
    sleep(1000)
    while bot.status == BotStatus.account_banned do
        bot.auto_reconnect = false
        bot:stopScript()
    end
end

if bot.level < 32 then
    sleep(math.random(1, 30) * 1000)

    if config["pnbInTutorial"] then
        queryInsert("Searching Tutorial")
        sleep(100)
        checkTutorial()
        sleep(100)
    end

    
    while true do
        takeMagplant()
        sleep(100)

        world, doorFarm = "USPJAITOUSJG","123"
        if config["takePick"] and findItem(config["itemHand"]) == 0 then
            takePickaxe()
            sleep(100)
        end
        -- USPJAITOUSJG|8HGMIUM8
        warp(world,doorFarm,true,true)

        if not nuked then
            local scanTile =  checkFire()
            if not scanTile.fire then
                tt = os.time()
                if scanTile.toxic then
                    queryInsert("Cleaning Toxic Waste")
                    sleep(100)
                    bot.anti_toxic = true
                    while true do 
                        local cntToxic = 0
                        for _,tile in pairs(getTiles()) do
                            if tile.fg == 778 then
                                cntToxic = cntToxic + 1
                                sleep(100)
                            end
                        end
                        if cntToxic == 0 then
                            bot.anti_toxic = false
                            break
                        end
                        sleep(100)
                    end
                end
                if config["event"]["enable"] and checkItemStorage() then
                    dropStorage(world)
                    sleep(100)
                end
                roleQuest()
                sleep(100)
                clearBlocks(world)
                sleep(100)
                harvest(world)
                sleep(100)
                clearBlocks(world)
                sleep(100)
                plant(world)
                sleep(100)
                tt = os.time() - tt
                waktuWorld[world] = math.floor(tt / 3600) .. " Hours " .. math.floor(tt % 3600 / 60) .. " Minutes " .. math.floor(tt % 60) .. " Seconds"
                print('Farming done. (' .. math.floor(tt / 3600) .. " Hours "..math.floor(tt % 3600 / 60).." Minutes)")
            else
                nukeWorldInfo(config["webhook"]["world"], world, doorFarm, "FIRED (FARM)")
            end
        else
            if nuked and string.find(warpStatus, "inaccessible") then
                nukeWorldInfo(config["webhook"]["world"], world, doorFarm, (warpStatus.." (FARM)" or "NUKED (FARM)"))
                
                waktuWorld[world] = "NUKED"
                treeWorld[world] = "NUKED"
            end
            if nuked and string.find(warpStatus, "high") then
                waktuWorld[world] = "HIGH LOADS"
                treeWorld[world] = "HIGH LOADS"
            end
        end
    end
end